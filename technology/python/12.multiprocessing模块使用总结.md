#### 背景简介

&emsp;最近在做一个爬虫项目，爬取站酷的用户信息，为了提高爬取速度，就想到了多进程，默认情况下，程序是单进程状态运行的，由于硬件的迅速发展，多核服务器已经很常见了，为了充分利用服务器的硬件资源，于是就使用了`multiprocessing`模块，当然多进程一般用在计算密集的程序，多进程有什么特点呢？

* 充分利用多核
* 避免了GIL的限制
* 内存空间独立

&emsp;`multiprocessing`模块有很多类，先说一下`Pool`.我们可以用它来创建进程池，示例代码如下:

```
from multiprocessing import Pool

def f(x):
	print x

if __name__ == '__main__':
	pool = Pool(4) #参数为进程池进程数，不填写默认为cpu_count()个数
	pool.map_async(f, xrange(100)) #异步执行,这里的map函数跟内建的功能一样但这里是多进程的
	p.close() #Prevents any more tasks from being submitted to the pool. Once all the tasks have been completed the worker processes will exit.进程池不再创建新的进程
	p.join() #相当于wait()防止产生僵尸进程, wait进程池中的全部进程。必须对Pool先调用close()方法才能join。

```

&emsp;`multiprocessing.dummy`模块和`multiprocessing`类似，只是前者使用的是线程,这样使用`multiprocessing`一个模块就可以简单地实现多线程和多进程了，挺吊的哈~

```
from multiprocessing.dummy import Pool as ThreadPool

def f(x):
	print x

if __name__ == '__main__':
	pool = ThreadPool(processes=4)
	pool.map(f,xrange(100))
	pool.close()
	pool.join()
```



#### 相关提示

* 在Linux系统上，当某个进程终止后，该进程需要被其父进程调用wait()，否则就成为了僵尸进程，所以有必要对每个子进程对象调用join()方法(实际上等同于wait)，对于多线程来说，由于是在一个进程里，所以没有必要了。
* 不一定说服务器有几个核心就起几个进程是最合适的，还有一点你没有考虑，那就是LINUX是分时操作系统，如果服务器只有一个核心，起100个进程肯定比起1个进程要快很多，因为同一时刻你的进程占用的CPU百分比要多，当然你的跑的快啦，不过你害的考虑进程间的资源同步和CPU的切换问题找到最合适的进程数。
* 多进程应该避免共享资源，在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数，再多进程情况下，由于每个进程有独立的内存空间，以上方法并不适合。此时我们可以通过共享内存和`Manager`的方法来共享资源，但这样提高了程序的复杂度并因为同步的需要而降低了程序的效率。
* 如果运行多线程过多，由于`GIL`的存在，线程间的切换就会影响程序的效率，所以就得不断测试优化。
* 一般来说，CPU计算密集型的程序最好使用多进程，充分利用CPU；IO密集型的程序最好使用多线程，但如果服务器有多核的话就不一定了，必须经过不断测试优化选择出最佳方案。
* 多进程模式中，服务器有几个核心那么就会fork出几个子进程，并且真正执行任务的是子进程，比如运行在8核心的服务器上，那么主进程会fork出8个子进程，并且这个8个进程去执行具体的任务，会占用很多资源，程序提供给系统8个进程，但是具体哪个进程占用哪个CPU是系统分配的，主进程只是当他们的父进程，并不执行具体的任务，从资源占用来看，父进程一般不会特别占用资源。(父进程只是负责分配任务，子进程负责处理任务)
* 关于GIL:

![GIL](https://raw.githubusercontent.com/hellorocky/techblog/master/picture/python_GIL.jpeg "GIL")
