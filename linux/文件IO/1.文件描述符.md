#### 简介

&emsp;接触Linux已经有3年多了,很早就知道在Linux系统中一切皆文件的设计思想,文件描述符这个词也经常听到,特别是工作后遇到的几次问题后,这个词也就算是一个老朋友了,遇到的问题这里不再详细赘述,关键词为`too many open files`,和普通用户登陆不进去终端,今天就详细介绍一下文件描述符吧,看了很多参考资料,深深感到Linux系统的强大.

* Linux文件的种类

```bash
* 普通文件, 使用-标示
-rw-r--r--  1 test  test     0B 11 25 14:43 readme.md

* 目录, 使用d标示
drwxrwxr-x. 2 test test 4.0K 11月 19 01:31 bin

* 链接文件, 使用l标示
lrwxrwxrwx. 1 test test    3 11月 19 01:29 lib64 -> lib

* 套接字文件,使用s标示
srwx------. 1 test test    0 11月 20 20:11 supervisor.sock

* 字符文件, 使用c标示,虚拟终端,键盘外设等
crw-rw-rw- 1 test test 5, 0 04-19 08:29 /dev/tty 

```

* 文件描述符定义

> 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 --维基百科

&emsp;说说我自己的理解,既然在Linux系统里一切皆文件,那么每一个进程肯定会读写很多文件,这里读写和文件都是泛指,比如说mysql服务启动的时候会创建mysql.socks文件,使用python读取一个文件等等,于是所有资源都有了统一的接口，开发者可以像写文件那样通过网络传输数据,我们也可以使用`cat /proc/*`命令查看Linux当前的运行状态等等.我们知道，每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息,Linux内核的进程控制块是task_struct结构体。其中的两个信息我们这里会用到,进程ID和文件描述符表.

&emsp;Linux内核为了维护每个进程跟这些文件的关系,在每个进程使用open/create来读/写一个文件时，内核返回的文件描述符标识该文件，将其作为参数传给read或write。每个进程的文件描述符表是独立不相关的.

![文件描述符1](https://raw.githubusercontent.com/hellorocky/blog/master/picture/8.file_descriptor_table.png)

![文件描述符2](https://raw.githubusercontent.com/hellorocky/blog/master/picture/9.file_descriptor_table.png)

在C标准库中分别用FILE *指针stdin、stdout和stderr表示。这三个文件的描述符分别是0、1、2，保存在相应的FILE结构体中。头文件unistd.h中有如下的宏定义来表示这三个文件描述符：

![标准文件描述符](https://raw.githubusercontent.com/hellorocky/blog/master/picture/10.std_file_descriptor.png)


#### CentOS7文件描述符相关设置

* 系统内核总的文件描述符

```bash
$cat /proc/sys/fs/file-nr
1408	0	51200

1408 表示系统已经使用的文件描述符数量
0 表示已经分配的但是没有使用的文件描述符的数量
51200 表示系统内核所能使用的最大文件描述符数量

$cat /proc/sys/fs/file-max
51200

系统允许打开的最大文件描述符数量是51200

临时修改:
#echo 51300 > /proc/sys/fs/file-max

永久修改:
#vim /etc/sysctl.d/local.conf

将fs.file-max=51200改为51300,然后执行:

#sysctl -p

这个动作修改后当前其实还没有改,重启后生效,所有一般先临时修改,然后永久修改
```