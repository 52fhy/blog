#### 僵尸进程是什么？
&emsp;一般来说，当一个进程终止后，其父进程会调用`wait()`或者`waitpid()`函数来取得子进程的终止状态，并由系统回收这部分资源。如果一个进程退出，其父进程没有调用`wait`或者`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，内核会持续保留子进程的退出状态等信息（等待父进程获取收尸），那么这个子进程就被成为`僵尸进程`。

#### 设置僵尸状态的目的是什么？

&emsp;维护子进程的信息，以便其父进程在某个时候获取，这些信息至少包括进程ID，进程的终止状态，以及该进程所使用的CPU时间，当其父进程调用`wait()`或者`waitpid()`函数时就可以得到这些信息。僵尸进程中保存着很多对程序员和系统管理员非常重要的信息，首先，这个进程是怎么死亡的？是正常退出呢，还是出现了错误，还是被其它进程强迫退出的？也就是说，这个程序的退出码是什么？其次，这个进程占用的总系统CPU时间和总用户CPU时间分别是多少？发生页错误的数目和收到信号的数目。这些信息都被存储在僵尸进程中，试想如果没有僵尸进程，进程执行多长我们并不知道，一旦其退出，所有与之相关的信息都立刻都从系统中清除，而如果此时父进程或系统管理员需要用到，就只好干瞪眼了。

#### 僵尸进程的危害

&emsp;类Unix操作系统提供了一种机制可以保证只要父进程想要知道子进程结束时的状态信息，就可以得到。这种机制就是：当子进程结束的时候，内核释放该进程所有的资源，包括打开的文件，CPU，内存等，但是仍然为其保留一定的信息，如上所述，直到父进程调用`wait`或者`waitpid`函数时才释放。这就产生了一个问题，如果父进程一直不调用`wait/waitpid`函数的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的`cat /proc/sys/kernel/pid_max  32768`(64位系统会更多)，如果大量的产生僵尸进程，系统将因为没有可用的进程号导致不能产生新的进程，呵呵呵。
&emsp;任何一个子进程（init除外）在exit()之后，并非马上就消失掉，而是留一个僵尸进程的数据结构等待其父进程的处理。这是每个子进程在结束时都要经过的阶段，如果在子进程结束之后，父进程没有来得及处理，这是用`ps`命令就能看到子进程的状态为`Z`，如果父进程能及时处理，可能用ps命令就看不到子进程的僵尸状态，但这不代表子进程不经过将是状态。但是如果父进程在子进程结束之前退出，则子进程将由init进程接管，init将会以父进程的身份负责处理子进程。

#### 僵尸进程的处理方式

&emsp;一般严格来说，僵尸进程的罪魁祸首并非僵尸进程本身，而是产生大量僵尸进程的那个父进程，因此当我们寻求如何处理的时候，那就是把那个父进程毙掉，枪毙了元凶之后，它产生的僵尸进程也就变成了`孤儿进程`，这些孤儿进程会被init进程所接管，init进程周期执行`wait`系统调用收割其收养的所有僵尸进程，释放他们所占用的进程表中的所有资源。	

1. 一般来说,父进程可能运行着很重要的任务,所以先发信号给父进程,让父进程收割处理僵尸进程,方法如下:

	```
	ps -eo stat,pid,ppid|awk '/^[zZ]/ {print $3}'|xargs kill -s SIGCHLD
	```

2. 如果父进程运行的任务不是很重要,那么可以直接杀死父进程.

	```
	ps -eo stat,pid,ppid|awk '/^[zZ]/ {print $3}'|xargs kill -9
		
	-e 显示全部的进程,相当于-A.
	-o 自定义格式化显示,后面的stat,pid等.
	awk匹配以Z或者z开头的行并显示父进程的id,然后强制杀死,当然这里也可以用grep -e '[zZ]'来匹配,但是grep不能匹配显示父进程的id.
	```


