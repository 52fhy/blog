#### 背景介绍

&emsp;2017年4月23的下午,是一个周末,突然收到短信报警喵喵微店挂了,查了错误日志后发现是redis出问题了,于是赶紧登录到redis服务器上查看日志,果然错误日志哗哗地刷,如下:

```bash
[27833] 23 Apr 14:30:38.973 #     Redis 2.8.18 crashed by signal: 7
[27833] 23 Apr 14:30:38.973 #     Failed assertion: <no assertion failed> (<no file>:0)
[27833] 23 Apr 14:30:38.973 # --- STACK TRACE
redis-rdb-bgsave *:6375(logStackTrace+0x43)[0x44bc03]
redis-rdb-bgsave *:6375(rdbSaveStringObject+0x16)[0x4328c6]
```
从网上大概搜了一下`linux信号7`的含义,大概是内存相关的错误,于是我赶紧查看了一下这个机器的内存占用,结果可用空间直接为0,而且swap也被占完了,再看看哪个进程占用了大量的内存,发现ES的锅,妈的,这ES真实服了,占用了一半的内存,于是联系了同事停止了ES服务,重启redis后就好了,一般来说,问题也就这样解决了,但是做技术的要有一颗钻研探索的心,下面跟着几个问题一路探索到底.

#### 打破砂锅问到底

1. 为什么发生内存不足?

```bash
1. ES里面存储的是日志月初很少,一到月底就会越来越多,所以4月24号正好是月末,占用的内存也是很高的
2. redis基本上每个几分钟就会执行一次快照备份,备份过程中会占用数据量的2倍的内存,所以如果redis中存储了10G的数据,发生一次快照备份的时候就会占用20G的内存,所以这也是导致故障发生的重要原因
```

#### redis的持久化

##### RDB方式介绍

&emsp;持久化是数据库将内存中的数据保存到到磁盘中的过程,为了让数据库重启后数据不丢失,redis持久化有两种RDB(快照方式)和AOF方式,这里先重点介绍RDB方式, 这也是redis默认的持久化方式.这种方式涉及到两个redis命令`save`和`bgsave`,两种方式都是执行一次RDB备份,区别在于前者是主进程上执行的,是阻塞的,执行过程中redis是不可以读写的,后者更好一些,它是异步的,主进程fork出一个子进程去执行这个过程,整个过程中主进程是不阻塞的,依然可以接收客户端的请求.

RDB过程:

1. 当满足触发RDB的过程时主进程首先会fork出一个子进程
 
2. 由于子进程会完全复制父进程的内存空间,所以这里让子进程去执行RDB过程把内存中的数据写到一个临时的压缩的二进制备份文件中,这里使用到了fork的写时复制技术,下面会说明.

3. 等到临时文件写完后就把之前的备份文件替换掉,备份文件一般名字为dump.rdb

4. 执行完后子进程退出


&emsp;咦,这个过程中如果遇到有写入文件是该怎么处理的呢?这就用到了linux fork时候的写时复制技术了,我的大概理解是这样的,redis主进程fork出一个子进程后,按说应该立即复制一份跟主进程完全一致的内存数据给子进程,但是一般主进程中的数据很大,或者说相对于fork这个动作来说很慢,而且浪费空间,Linux设计出了当刚fork出子进程的时候父子进程内存指向同一块内存地址,一直等到主进程或者子进程有`写入`动作的时候,内核才会真正复制一份内存出来,对于redis这例子来说,当子进程执行RDB过程中,如果有client有对主进程写的请求,那么就会触发内存地址复制的过程,这时候子进程接着执行历史未改变的数据进行备份操作,主进程的数据则在之前数据的基础上有更新了,注意这时候内存会占用数据量的2倍.所以RDB过程一般会占用大量内存

##### RDB优缺点

优点:

1. dump.rdb文件是一个压缩的某一时刻的全部数据的快照,可以实现每天一次备份,实现历史某一天数据的恢复

2. 方便传输到其它节点恢复,这也是主从复制的很重要的一个环节

3. 这种方式最大化了redis的性能,因为它是fork一个子进程来执行备份的,主进程依然可以处理请求,这里注意,因为每一次备份都是全部数据的快照,如果太频繁地执行备份的话就会影响IO了

4. 相比较AOF来说恢复的更快,一是RDB文件中每一条数据只有一条记录,不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。 

缺点:

1. 最大的缺点当然是不是备份的数据永远不是最新的,备份的时候如果有新的写入,那么这一次备份完的数据就不是最新的
2. 频繁RDB也是很占用IO/CPU资源的








#### 参考链接

[Redis持久化 Snapshot和AOF说明](http://www.cnblogs.com/zhoujinyi/archive/2013/05/26/3098508.html)
[redis.io](https://redis.io/topics/persistence)
