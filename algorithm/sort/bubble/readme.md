# 冒泡排序

#### 排序方法


&emsp;假设输入的数组R[1,2...n],每个记录的值为R[i],i从0开始.根据从小到大的原则,从左往右扫描数组R,凡扫描到左边的值比右边的值大的时候就交换位置.如此反复进行直到整个数组按照从小到大排列为止.

1. 初始

 R[1..n]为无序序列.

2. 第1趟

 从左至右依次两两比较,发现左边比右边大的时候就交换位置,经过过第一趟比较,最大的数字排到了最右边R[n].

3. 第2趟

 扫描[1, n-1],扫描完毕时,"次重"的气泡排到最后,经过n-1趟扫描可以得到有序序列[1,n].

 > 扫描n-1趟时,除了第一位,后面的已经是排序完的序列了,第一个也不用排序了,所以总共需要n-1趟排序.

#### 排序过程

http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/maopaopaixu.htm

#### 算法分析

1. 算法的最好时间复杂度

 若文件的初始状态为正序,一趟扫描即可完成排序.所需的元素比较次数C和记录移动次数M均达到最小值:

 Cmin = n-1

 Mmin = 0  

2. 算法的最坏时间复杂度

 若初始文件是反序的,需要进行n-1趟排序.每趟排序要进行n-i次元素的比较(i是次数,且1=<i<=n-1),而且每次比较都必须移动记录3次来达到交换记录位置(a=1;b=2;tmp=a;a=b;b=tmp). 在这种情况下,比较次数和移动次数均达到最大值:

 Cmax = ((n-1)+1)*(n-1)/2 = n(n-1)/2 = O(n²)

 Mmax = 3n(n-1)/2 = O(n²)

 冒泡排序的最坏时间复杂度为O(n²)

3. 平均时间复杂度

 未优化版本为O(n²)

4. 算法稳定性

  冒泡排序为原地排序,且它是稳定的.

5. 空间复杂度

 冒泡排序是原地排序,所以占用的空间跟数组的长度无关,为O(1)    

#### 算法优化

1. 每一趟扫描之前设定一个变量,当扫描完后,如果有元素交换,则改变该变量的值,如果没有交换则该值不改变,该趟扫描完的时候判断该值是否有改变,如果没有改变,则代表这一趟没有发生交换,然后直接return退出,不用再做一些无用的扫描比较,从而减少排序的趟数.

2. 冒泡排序的不对称性(默认从左往右扫描),每一趟扫描仅仅能移动一个位置,因此会造成这种情况,在排序过程中交替改变扫描方向,可改进不对称性.

 * 能一趟完成扫描的情况: [66,1,2,3,4,5]

 * 需要n-1趟扫描完成的情况: [3,4,5,6,7,8,1]

---





---  
<img style="transform:rotate(90deg);;" src="https://raw.githubusercontent.com/hellorocky/blog/master/picture/2.bubble_sort.jpg">
