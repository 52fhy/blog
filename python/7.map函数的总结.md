####官方翻译
`map(function, iterable, ...)`将function应用于每一个可迭代的对象并返回一个列表作为结果.如果传入额外的可迭代的元素即不止一个iterable参数,function必须接受这些参数并且`并行`地处理它们.如果其中一个iterable比另一个短,它会假定用None元素补充.如果function是None,默认是恒等函数,即F(x)=x;如果有很多个参数,map()会返回一个列表,列表中为包含相应结果的元组.iterable可以是一个序列或者是一个可迭代的对象,结果总是返回一个列表.

####常用总结

1. 牛刀小试

```
>>>def sqrt(i):
>>>	   return i ** 2
>>>lst = [1,2,3]
>>>map(sqrt,lst)
>>>[1,4,9]
```

2. 多个可迭代参数,并行处理参数.

```
>>>lst1,lst2,lst3 = [1,2,3],[4,5,6],[7,8,9]
>>>def fun(a,b,c):
>>>    return a*100 + b*10 + c
>>>map(fun,lst1,lst2,lat3)
>>>[147,258,369]
```

3. 当function为None的时候.	

```
>>>lst1,lst2,lst3 = [1,2,3],[4,5,6],[7,8,9]
>>>def fun(a,b,c):
>>>    return a*100 + b*10 + c
>>>map(None,lst1,lst2,lat3)
>>>[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

4. map()看起来像列表推导公式,来一发看看:

`map(func,iterable)` 基本上等于 `[f(x) for x in iterable]`

```
>>>def sqrt(i):
>>>	   return i ** 2
>>>lst = [1,2,3]
>>>map(sqrt,lst)
>>>[1,4,9]
>>>
>>>print [sqrt(i) for i in lst]
>>>[1,4,9]
```

5. Too young,too simple,看看下面的情况.

列表推导式是嵌套for循环(笛卡尔乘积),而map()是并行处理.

```
>>>lst1,lst2,lst3 = [1,2,3],[4,5,6],[7,8,9]
>>>def fun(a,b,c):
>>>    return a*100 + b*10 + c
>>>map(fun,lst1,lst2,lat3)
>>>[147,258,369]

>>>print [fun(a,b,c) for a in lst1 for b in lst2 for c in lst3]
>>>[147, 148, 149, 157, 158, 159, 167, 168, 169, 247, 248, 249, 257, 258, 259, 267, 268, 269, 347, 348, 349, 357, 358, 359, 367, 368, 369]
```

