### <p align=center>`Yelp`公司真实场景下的`Docker`</p>


【编者的话】本文主要讲述了`Docker`在`Yelp`真实生产环境下使用的一些最佳实践和一些部署经验。

每天有成千上万的企业正在使用Yelp的SeatMe系统去管理它们的就座和预定。鉴于这些系统对于很多企业的重要性，拥有一个稳定的系统对我们来说是非常地重要的。这篇博客将要深入地讲解我们是怎样使用`Docker`可靠地开发跟部署`Yelp SeatMe`系统的。`Docker`是一个非常强大的生产环境助推器，已经大大简化了我们的部署方式。希望通过这篇博客让大家了解怎样在各自的团队中使用`Docker`。首先，我要简单介绍一下`Yelp SeatMe`系统的背景，和它的开发部署方式。

#### `Yelp SeatMe`是什么？

餐厅通过我们原生的iPad应用或网站接受和管理客户的预定。我们保持客户所有的终端的信息实时同步，同时我们也支持离线更改当客户在没有联网的情况下。

我们的技术栈：

 * 客户端的`Javascript`，我们把[Backbone](http://backbonejs.org/)用在我们单页的应用程序上
 * `Python`是我们后端的语言，[Django](https://www.djangoproject.com/)作为我们的web框架
 * 我们使用[Celery](http://www.celeryproject.org/)和[RabbitMQ](http://www.rabbitmq.com/)来处理我们的异步任务
 * [Postgres](http://www.postgresql.org/)数据库，使用触发器的数据验证和更新通知，以支持我们的同步协议和长轮询引擎

我们把整个平台都放到了`AWS`上，我们使用[Chef](https://www.chef.io/chef/)作为我们的主要工具来配置服务器，管理部署和组织我们的测试/灰度/线上环境。

#### 在生产环境使用`Docker`

一年前，我们使用`Docker`容器开启了一种新的方式来让我们的（测试环境，灰度环境，生产环境）更加地一致和让我们的部署流程更加简化。

在我们使用容器之前，所有的部署一个web应用的逻辑被放在`Chef`的配置文件里。部署流程大概像这样：

 * 设置目录权限
 * 安装`python`的依赖组件和依赖包
 * 下载一个指定的`git`标签到本地的`git`分支
 * 保留最近的几个版本来确保我们可以快速回滚

这些`Chef`的配置文件对于新工程师来说不是那么容易被接受，因为它们使用一种不同的语言（Ruby）而且使用一个复杂的框架。这些设置使部署变得脆弱和不易改变。容器来拯救啦！

通过使用`Docker`，我们能够简化`Chef`管理的部署部分，改成简单的`Docker`容器的操作：

 * 拉取一个指定的`Docker`镜像到服务器
 * 通过健康检查来是服务器停止
 * 停止存在的容器
 * 给新的镜像打一个易读的名字的标签来区分出当前的版本（www:latest）
 * 启动这个镜像（以及所有它的文件系统的映射等等），并使用一个新的名字来命名这个容器（www）

使用`Docker`的好处：

 * 通过对`Dockerfile`的代码控制管理的编辑来增加开发者对环境的控制
 * 消除服务器环境的不统一，正如之前所说的`Chef`已经提供的
 * 减少了`Chef`配置成百上千应用所需要的代码量
 * 集中了部署镜像库而且永远可以对应到某个具体的`git`提交
 * 我们持续集成了我们的`Docker`镜像，所以每一次`code review`通过后总会生成一个可部署的镜像
 * 现在开发者可以修改系统级别的包，而不需要运维团队来做这件事了

经过两个月的开发和测试，我们在2014年10月初期把`Docker`用到了生产环境而且没有遇到很大的阻碍。


#### 向`Docker`迁移过程中需要注意的事情

`Docker`是一个相对比较新的技术，所以当你完成一些事情的时候当然会遇到‘陷阱’。这里有一些关于开发和部署`Docker`的经验/提示。

* 确保充分地测试了你的文件系统

这里有一些对`Docker`可用的文件系统，`AUFS`被认为是上一代的文件系统，`Device Mapper`被认为是目前这一代的文件系统。我们发现尽管测试是在本地文件系统，当使用`Device Mapper`文件系统的时候就会出现崩溃，同时整个系统也会挂。当然这很可能是内核和发行版的不同所造成的，我们发现`AUFS`在我们的生产环境中非常地稳定。务必充分地测试你的文件系统尤其是通过在测试环境中不断地重复部署的方式。

* 多次构建`Docker`镜像是很慢的而且磁盘里的镜像会很快地变大

由于`Docker`文件系统分层的工作原理，如果你改变了一些初期层序的东西，你必须重新构建所有有继承关系的分层。搞清楚从时间或者网络接入的角度和为减少将来重新构建而梳理你构建步骤的角度来说哪些步骤是昂贵的不是一件很容易的事情。为了减少构建层和重构时间而将某些命令整合成单个命令是一个非常精细的艺术活。考虑一下缓存成功构建后的`Docker`镜像来减少构建的次数吧。

* 务必使用明确的命令来构建和启动容器或者编写`Dockerfile`

我们使用模板来做这件事情。一旦有一些参数要传给`docker run`，你想要这些参数文档化和很容易地被找到。如果这些参数随着时间或者随着一个新版本`Docker`的发布，你不必去改变这个服务器上的一个配置文件或者一个`shell`的`alias`，仅仅是代码的改变。

* 镜像文件和容器实例不会自动地回收

这已经被谈论了很长时间了，我们发现当我们所有的服务器硬盘神秘变满地时候，我们部署过的每一个镜像依然保存在服务器上直到我们删除它。我们已经使用一些简单的管理脚本来减少磁盘的占用了，直到我们发现了像[docker-custodian](https://github.com/yelp/docker-custodian)一样的工具才真正解决了这个问题。

* 考虑把你的镜像分层到多个`Dockerfiles`来加速构建次数

以上我们前面讨论过镜像缓存，我们已经完成了一个多层`Docker`镜像策略，这个策略是让镜像之间可以互相继承。

包含一些系统包的基础镜像构建地很慢但是改变很频繁。

生产环境中的`web`镜像继承自这些基础镜像，同时也包含了一系列的编译好的`Python`包和某一时刻的源代码快照。这样会快速地构建除非遇到`requirements.txt`文件的变动，这个变动会触发`virtualenv`的重新构建。

开发者的`web`镜像继承自生产环境的镜像，并且增加了一些跑`selenium`测试（Xvcon，google-chrome）的工具和一些开发者的工具。然后开发者利用文件系统将他们的新的代码映射到容器当中，并且在生产环境`web`镜像中覆盖快照。

* 遇到紧急情况，你依然可以进入容器内`debug`你的代码

最初当你在容器内跑你的代码的时候，它就像在你跟你的代码之间放了一个隔离层，并且这个隔离层阻止了大量的正常`debugging`技术。当它不被认为是最佳实践的生产环境系统的时候，当在测试环境（尤其是在开发环境）的时候，你很可能打开一个终端执行`docker exec -ti <containerid> bash`然后用平常的命令比如`strace`来检查你的代码或系统是否正常。

* 你需要一个日志管理的策略

这听起来是一个再普通不过的话题，但是日志管理对于`Docker`来说是非常棘手的问题。你可以用一些简单的技术去映射宿主机的文件系统到容器中简单地把日志保存在宿主机上，但是当你在这个宿主机上起更多的容器实例的时候这个方法很快就会失败。

最后，经过大量的实验，我们已经取得巨大的成功将应用程序的日志通过`UDP`直接打到宿主机的`syslog`上。在`Docker`1.7版本之前，做着一件事情需要一个技术来找到`syslog`宿主机的正确IP地址，后来我们通过传递环境变量解决了这个问题。


#### 关于未来

总的来说，容器化已经取得了巨大成功。比如说，当`Shellshock`漏洞被公布的时候，我们的事故响应仅仅是一次容器的构建和一次`Chef`的执行。尽管发展步履维艰，`Docker`已经是一个巨大的改变，我们非常乐意继续研究它。有了一个稳定的`web`基础构件后，我们已经找到更新更有效率的方法来测试，部署和管理我们的基础构件，同时也找到了更快的开发迭代的方法。我们希望能在今后的文章中分享这些方法，敬请关注吧！


