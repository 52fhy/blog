####简单介绍

&emsp;cgroup是control group的缩写,是用来对单个/多个进程进行资源利用上的限制,计费,隔离的Linux内核的一种特性.这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。

####主要作用

* Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
* Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。
* Accounting: 一些审计或一些统计，主要目的是为了计费。
* Control: 挂起进程，恢复执行进程。

&emsp;使用cgroup,系统管理员可以更具体地对系统资源的分配,优先顺序,拒绝,管理,监控等.提高总体效率.
&emsp;实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：

* 隔离一个进程集合(如nginx的所有进程),并限制它们所消费的资源,比如绑定CPU的核.
* 为这组进程分配足够明确的内存.
* 为这组进程分配相应的网络带宽和磁盘空间.
* 通过设备白名单方式限制进程访问某些设备.

####牛刀小试

* cpu使用限制

先运行一个特别吃CPU的程序`echo 'while True: pass'|python`,运行`top`查看:

```
 PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                              
26544 root      20   0  111m 4252 1700 R 99.9  0.0   0:25.06 python
```

然后在`/sys/fs/cgroup/cpu/`下面新建一个目录`test`,创建好以后里面默认有好多配置文件,

```
root@ubuntu:~# cat /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us 
-1
root@ubuntu:~# echo 20000 > /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us
```
我们看到，这个进程的PID是26544，我们把这个进程加到这个cgroup中：

```
# echo 26544 >> /sys/fs/cgroup/cpu/test/tasks
```

然后看看`top`中立马变成了20%.

* mem的使用限制

&emsp;用本机的pycharm来测试,先开启pycharm,利用top看看内存的使用:

```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                       
 3337 rocky     20   0 1951500 623372 160488 S   0.0  8.1  38:54.22 chrome                                                                        
31749 rocky     20   0 3883628 457188  49824 S  10.9  5.9   1:43.56 java 
```
```
$ mkdir /sys/fs/cgroup/memory/test
$ echo 64k > /sys/fs/cgroup/memory/test/memory.limit_in_bytes
$ echo 31749 > /sys/fs/cgroup/memory/test/tasks
```

你会看到，一会上面的进程就会因为内存问题被kill掉了。

* disk的使用限制

我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）

```
sudo dd if=/dev/sda1 of=/dev/null
```

我们使用`iotop`命令查看读写速度55MB/s

```
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND          
8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null
```

然后我们先创建一个blkio的目录.

`mkdir /sys/fs/cgroup/blkio/test`

并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：
```
root@ubuntu:~# echo '8:0 1048576'  > /sys/fs/cgroup/blkio/test/blkio.throttle.read_bps_device 
root@ubuntu:~# echo 8128 > /sys/fs/cgroup/blkio/test/tasks
```

再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。

```
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND          
8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null
```

&emsp;我使用的是ubuntu,在`/sys/fs`下有一个cgroup目录,里面有cpu,memery等cgroup的子系统,下面详细说一下:

* blkio -- 这个子系统为块设备设定输入输出限制,比如物理设备(硬盘,USB等等).
* cpu -- 这个子系统使用调度程序提供对CPU的cgroup任务访问.
* cpuacct -- 这个子系统自动生成cgroup中任务所使用的cpu的报告.
* cpuset -- 这个子系统为cgroup中的任务分配独立的cpu(多核系统上)和内存节点.
* devices -- 这个子系统可以允许或者拒绝cgroup中的任务访问设备.
* freezer -- 这个子系统挂起或者恢复cgroup中的任务.
* memory -- 这个子系统设定cgroup中任务使用的内存限制,并自动生成内存资源使用报告.
* net_cls -- 这个子系统使用等级识别符(classid)标记网络数据包,可允许linux流量控制程序tc识别从具体cgroup中生成的数据包.
* net_prio -- 这个子系统用来设计网络流量的优先级.
* hugetlb -- 这个子系统主要针对于HugeTLB系统进行限制,这是大叶文件系统.


