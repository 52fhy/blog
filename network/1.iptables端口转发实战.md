工作中经常用到端口转发的场景,这里总结一下3中场景.

#### 跨主机端口映射

测试环境:

| IP       | 端口           | 备注  |
| :-------------: |:-----:|:-----:|
| 172.100.102.101      | 1234 | 标号A |
| 172.100.102.161      | 4321      | 标号B |
|172.100.108.233 | | 客户端 |

现在在A上起一个监听端口1234的web server,达到让客户端访问B的4321端口来转到A的1234端口上.所有的iptables规则都在B上配置.

1. 修改内核参数

```
将B机器的/etc/sysctl.conf中net.ipv4.ip_forward = 1这个参数的值改为1,默认为0
然后执行sysctl -p,让修改生效
```

2. 添加规则

```
iptables -t nat -A PREROUTING  -m tcp -p tcp --dport 4321 -j DNAT --to-destination 172.100.102.101:1234
iptables -t nat -A POSTROUTING -d 172.100.102.101-p tcp -m tcp --dport 1234 -j SNAT --to-source 172.100.102.161
```

注意,这里客户端访问机器B的4321端口的时候,会转发到机器A的1234端口,但是从A机器上看到的请求来源为B的IP地址而不是客户端的IP地址

#### 本机端口的转发

比如我想访问主机B的2222端口然后,转发到本机的1111端口上,那么规则如下:

```
iptables -t nat -A PREROUTING -p tcp --dport 2222 -j REDIRECT --to-ports 1111
```

#### 跨主机端口映射,保留源IP地址

这个方案的结果跟第一种情况类似,但是从A主机上看日志的请求来源是真实的客户端的IP地址,真实的场景比如老数据库的迁移,如果让大量的服务修改服务的数据库地址的话,工作量很大,这时候就可以使用这种方法让服务不用修改数据库的IP地址,而是在老数据库所在的服务器上添加iptables规则,又由于数据库的授权是根据真实的源IP,所以有了这一篇文章.

* B主机上执行

```
ifconfig eth0:1 10.10.10.10 netmask 255.255.255.0
iptables -t nat -A PREROUTING -p tcp -m tcp --dport 4321 -j DNAT --to-destination 10.10.10.11:1234
```

* A主机上执行

```
ifconfig eth0:1 10.10.10.11 netmask 255.255.255.0
ip route add 0/0 via 10.10.10.10 table test dev eth0
ip rule add from 10.10.10.11 to 0/0 table test
```